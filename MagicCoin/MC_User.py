from hashlib import sha256
import time
import random, string

from MagicCoin.MC_Contract import Contract
from MagicCoin.MC_Transaction import Transaction
from MagicCoin.MC_TxnMemoryPool import TxnMemoryPool
from MagicCoin.MC_Output import Output

teams = ['Yankees','Red Sox','Blue Jays','Rays','Orioles','Indians','Twins',
         'Tigers','White Sox','Royals','Astros','Athletics','Mariners',
         'Angels','Rangers','Braves','Phillies','Nationals','Mets',
         'Marlins','Cubs','Brewers','Cardinals','Pirates','Reds',
         'Diamondbacks','Rockies','Dodgers','Giants','Padres']

class User:
    """Class representing User in each node.

       User will generate contracts (post bets) and also
       accept contracts (accept bets).
    """

    def __init__(self, public_key, balance = 1000000000):
        self.public_key = public_key
        self.balance = balance

    def generate_random_contract(self):
        """User generates random contract (creates a bet)
           to simulate mining.
        """

        x = random.randint(0,29)
        y = random.randint(0,29)
        team_a = teams[x]#str(Output.generate_random_script(5))
        team_b = teams[y]#str(Output.generate_random_script(5))
        event = team_a + " vs " + team_b
        team = team_a
        quantity = Output.generate_random_value(1000, 5000)
        current_time = time.time()
        expiration_date = current_time + 4
        odds = float(random.random() * 2.0)
        source_of_truth = 'www.espn.com'
        check_result_time = current_time + 5
        contract = Contract(event, team, quantity, expiration_date, odds, source_of_truth, check_result_time,
                            self.public_key)
        dig_sig = sha256((self.public_key + str(time.time()) + contract.contract_hash_value).encode('utf-8')).hexdigest()
        contract.party1_digital_sig = dig_sig
        return contract

    def accept_bet(self, contract):
        """User accepts a contract (accepts a bet) generated by another user
           and consequently two transactions are created for each contract.
           
           According to the outcome of the bet, only 1 out of the 2 transactions
           are validated.
           Transaction 1: The transaction where the bet posting user loses the bet and in return
           the bet accepting user receives the reward in MagicCoin (contract.quantity * odds).
           Transaction 2: The transaction where the bet posting user wins the bet and in return
           receives the reward in MagicCoin (contract.quantity) paid by the bet accepting user.
        """
        # create digital signature of the user accepting the bet
        dig_sig2 = sha256((self.public_key + str(time.time())).encode('utf-8')).hexdigest()
        # contract quantity in MagicCoin for each of the two transactions created
        money_paid_by_the_better = int(contract.quantity)
        money_paid_by_the_receiver = int(contract.quantity * contract.odds)
        input_1 = Output(value=money_paid_by_the_better,
                         public_address=contract.party1_public_key,
                         digital_sig=contract.party1_digital_sig)
        output_1 = Output(value=money_paid_by_the_better - 50,
                          public_address=self.public_key,
                          digital_sig=dig_sig2)
        input_2 = Output(value=money_paid_by_the_receiver,
                         public_address=self.public_key,
                         digital_sig=dig_sig2)
        output_2 = Output(value=money_paid_by_the_receiver - 50,
                          public_address=contract.party1_public_key,
                          digital_sig=contract.party1_digital_sig)
        # create two transactions for each accepted contract (bet)
        txn_1 = Transaction(input_1, output_1, contract)
        txn_2 = Transaction(input_2, output_2, contract)
        return txn_1, txn_2